# Жадібні алгоритми та динамічне програмування
## Завдання: видача решти касовим апаратом

### Набір монет
Використовується фіксований набір номіналів:

[50, 25, 10, 5, 2, 1]

---

## 1. Жадібний алгоритм — `find_coins_greedy`

### Ідея
На кожному кроці вибирається **найбільша можлива монета**, яка не перевищує залишок суми.

### Алгоритм
1. Перебираємо монети від більшої до меншої
2. Беремо максимально можливу кількість кожної монети
3. Зменшуємо залишок суми

### Складність
- Часова: **O(n)**, де n — кількість номіналів (тут константа)
- Просторова: **O(1)**

### Переваги
- Дуже швидкий
- Простий у реалізації
- Ідеально підходить для касових систем з "канонічними" номіналами

### Недоліки
- **Не завжди дає мінімальну кількість монет** для довільних наборів номіналів

---

## 2. Динамічне програмування — `find_min_coins`

### Ідея
Для кожної суми від 0 до `amount` зберігаємо мінімальну кількість монет, необхідних для її формування.

### Алгоритм
1. `dp[i]` — мінімальна кількість монет для суми `i`
2. Для кожної суми перебираємо всі номінали
3. Запамʼятовуємо останню використану монету
4. Відновлюємо рішення з кінця

### Складність
- Часова: **O(amount × n)**
- Просторова: **O(amount)**

### Переваги
- Завжди знаходить **оптимальне рішення**
- Працює для будь-якого набору номіналів

### Недоліки
- Повільний для дуже великих сум
- Вимагає більше памʼяті

---

## 3. Порівняння ефективності

| Критерій | Greedy | Dynamic Programming |
|--------|--------|---------------------|
| Швидкість | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| Памʼять | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| Оптимальність | ⭐⭐⭐⭐* | ⭐⭐⭐⭐⭐ |
| Великі суми | ✅ | ❌ |

\* Для даного набору монет жадібний алгоритм дає оптимальний результат.

---

## 4. Висновок

- Для **реальних касових систем** з фіксованими номіналами доцільно використовувати **жадібний алгоритм**
- Динамічне програмування варто застосовувати:
  - для нестандартних наборів монет
  - у навчальних та аналітичних задачах
- На великих сумах жадібний алгоритм є **значно ефективнішим**

---

## ▶ Запуск

```bash
python test_coins.py
