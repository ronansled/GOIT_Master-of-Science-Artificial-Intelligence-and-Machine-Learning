Task 6 — Жадібні алгоритми та динамічне програмування
Опис завдання

Мета завдання — оптимізувати вибір страв у межах обмеженого бюджету так, щоб максимізувати сумарну калорійність.

Використовуються два підходи:

Жадібний алгоритм (greedy_algorithm)

Вибирає страви за коефіцієнтом калорії/вартість.

Кожну страву можна вибрати лише один раз.

Швидкий, але не гарантує оптимальності для загального випадку 0/1.

Динамічне програмування (dynamic_programming)

Класична задача 0/1 Knapsack: максимізує сумарні калорії при заданому бюджеті.

Забезпечує оптимальне рішення, складність O(n * budget).

Структура проекту
task-6-budget-optimization/
├── budget_opt.py       # Реалізація алгоритмів greedy та DP
├── test_budget_opt.py  # Тести та демонстрація
└── README.md           # Документація

Формат вхідних даних

Список страв представлений у вигляді словника:

items = {
    "pizza": {"cost": 50, "calories": 300},
    "hamburger": {"cost": 40, "calories": 250},
    "hot-dog": {"cost": 30, "calories": 200},
    "pepsi": {"cost": 10, "calories": 100},
    "cola": {"cost": 15, "calories": 220},
    "potato": {"cost": 25, "calories": 350}
}


cost — вартість страви (ціна)

calories — калорійність страви

Використання
1. Імпорт функцій
from budget_opt import items, greedy_algorithm, dynamic_programming, summary

2. Виконання алгоритмів
budget = 80

# Жадібний алгоритм
greedy_selection = greedy_algorithm(items, budget)
print("Greedy selection:", greedy_selection)
print("Totals:", summary(greedy_selection, items))

# Динамічне програмування
dp_selection = dynamic_programming(items, budget)
print("DP selection:", dp_selection)
print("Totals:", summary(dp_selection, items))

Приклад результату

Для бюджету 80:

Greedy selection: {'potato': 1, 'pizza': 1}
Greedy totals: {'total_cost': 75, 'total_calories': 650}

DP selection: {'potato': 1, 'cola': 1, 'hamburger': 1}
DP totals: {'total_cost': 80, 'total_calories': 820}


Як видно, жадібний алгоритм не завжди дає оптимальний результат, а алгоритм динамічного програмування забезпечує максимальні калорії.

Тестування

Запустіть test_budget_opt.py:

python test_budget_opt.py


Перевіряється, що вартість обраних страв не перевищує бюджету.

Перевіряється, що DP не дає гірших результатів за калоріями, ніж жадібний алгоритм.

Пояснення алгоритмів
Жадібний алгоритм

Обчислюється коефіцієнт calories / cost для кожної страви.

Страви сортуються за спаданням цього коефіцієнта.

Додаються до набору, поки вистачає бюджету.

Динамічне програмування (0/1 Knapsack)

Створюється таблиця dp[i][w] — максимальні калорії, використовуючи перші i предметів і бюджет w.

Для кожного предмета вибираємо, брати його чи ні, та обираємо максимальне значення.

Відновлюємо набір предметів із таблиці DP.

Висновки

Жадібний алгоритм швидкий, але не гарантує оптимальність.

Динамічне програмування завжди дає оптимальне рішення.

Алгоритми демонструють різницю між локальною жадібністю та глобальною оптимальністю.